---
title: designing-data-intensive-application-7
date: 2020-09-28 11:27:19
tags:
- transaction
---
### 현실세계 문제점
- 데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있다.
- 애플리케이션은 언제라도 죽을 수 있다.
- 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될 수 있다.
- 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
- 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다.
- 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.

### Transaction mechanism
- 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.
- 개념적으로 한 트랜잭션 내의 모든 읽기와 쓰기는 한 연산으로 실행된다.
- 트랜잭션은 전체가 성공하거나 실패한다.

### ACID
- 테오 하더(Theo Harder), 안드레아스 로이터(Andreas Reuter)는 데이터 베이스에서 내결함성 메커니즘을 나타내는 용어를 확립했다.
- Atomicity(원자성)
- Consistency(일관성)
- Isolation(격리성)
- Durability(지속성)
- 그러나 현실에서는 데이터베이스마다 ACID구현이 제각각이다. 
- ACID compliant 한다고 할때 그 시스템에서 실제로 어떤 것을 기대할 수 있는지 분명하지 않다. (ACID 표준을 따르지 않는 시스템은 때로 BASE라고 불린다.)
    - Basically Available
    - Atomicity
    - Soft state
    - Eventual Consistency

### Atomicity
- 일반적으로 원자적이란 더 작은 부분으로 쪼갤 수 없는 뭔가를 가리킨다.
    - 시스템은 연산을 실행하기 전이나 실행한 후의 상태에만 있을 수 있으며 그 중간 상태에는 머물수 없다.
    - ACID의 맥락에서 보면 원자성은 동시성과 관련이 없다.
    - 여러 쓰기 작업이 하나의 원자적 인 트랜잭션으로 묶여 있는데 결함 때문에 왼료(커밋)될 수 없다면 어보트되고 
      데이터베이스는 이 트랜잭션에서 지금끼지 실행한 쓰기를 무시하거나 취소해야 한다.
    - 어보트 능력 (abortability)이 원자성 보다 나은 단어겠지만 원자성이 자주 쓰이므로 이 단어를 계속 사용하겠다.

### Consistency
- 유감스럽게도 같은 단어가 최소 네가지 의미로 쓰이고 있다.
- 복제 일관성(replica consistency)과 비동기식으로 복제되는 시스템에서 발생하는 최종적 일관성(eventualconsistency) 문제에 대해 설명했다
- 일관성 해싱은 어떤 시스템들에서 재균형화를 위해 사용하는 파티셔닝방법이다.
- CAP 정리(9장 침고)에서 일관성이란 닫어는 선형성(Iinearizability)을 의미한다
- ACID의 맥락에서 일관성은 데이터베이스가 “좋은 상태”에 있어야 한다는 것의 애플리케이션에 특화된 개념을 가리킨다，
- 데이터에 관한 어떤 선언 (불변식 {invariant})이 있다는 것이다.

### Isolation
![](/images/data-intensive/chapter_7/transaction_isolation.png)
- 격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다.
- 데이터베이스는 실제로는 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.
- 직렬성 격리(serializable isolation)는 성능 손해를 동반하므로 현실에서는 거의 시용되지 않는다.

### durability
- 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.

### 다중 객체 트랜잭션의 필요성

### read commited
- 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다(더티 읽기가 없음)
- 데이터베이스에서 쓸 때 커밋된 데이터만 덮어쓰게 된다(더티 쓰기가 없음)

### 더티 읽기 방지
![](/images/data-intensive/chapter_7/prevent_dirty_read.png)
- 트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 생기면 다른 트랜잭션이 일부는 갱신된 값을， 일부는 갱신되지 않은 값을 볼수있다 
- 트랜잭션이 어보트되면 그때까지 쓴 내용은 모두 롤백돼야 한다. 데이터베이스가 더티 읽기를 허용하면 트랜잭션이 나중에 롤백될 데이터， 
  즉 실제로는 데이터베이스에 결코 커멋되지 않을 데이터를 볼 수 있다 그 결과를 따져보려 하면 곧 머리가 흔란스러워질 것이다.
  
### 더티 쓰기 방지
- 먼저 쓴 내용이 아직 커잇되지 않은 트랜잭션에서 쓴 것이고 니중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어써버리면 어떻게 될까?

### SnapShot Isolation
- 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다는 것
- MVCC(multi-version concurrency control)
- 오라클에서는 직렬성, Postgresql, mysql에서는 repeatable read라고 한다.

### 원자적 쓰기 연산
- 커서 안정성(cursor stability) : 보통 객체를 읽을 때 그 객체에 독점적인(exclusive) 잠금을 획득해 구현하며 갱신이 적용될 때 까지 다른 트랜잭션에서 해당 객체를 읽지 못하게 한다.
- 명시적 잠금 : ex) BEGIN TRANSACTION
- 갱신 손실 자동 감지 : read-modify-write 주기가 순차적으로 실행되도록 강제함으로써 갱신 손실을 방지하는 방법이다.
    - 관리자가 갱신 손실을 발견하면 트랜잭션을 어보트 시키고 주기를 재시도하도록 강제하는 방법
        - 장점 : snapshot isolation 과 결합해 효율적으로 수행이 가능 
- Compare-and-set : 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것이다. 현재 값이 이전에 읽은 값과 일치하지 않으면 갱신은 반영되지 않고 주기를 재시도한다.
- 최종 쓰기 승리 : 갱신 손실이 발생하기 쉽다.

### 쓰기 스큐와 팬텀
- write skew :  ![](/images/data-intensive/chapter_7/write_skew.png)
1. select 질의가 어떤 검색 조건에 부합하는 로우를 검색함으로써 어떤 요구사항을 만족하는지 확인한다.
2. 첫 번째 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지(해당 연산을 계속 처리할지 사용자에게 오류를 보고하고 중단할지) 결정한다.
3. 어플리케이션이 계속 처리하기로 결정했다면 데이터베이스에 쓰고(Insert, Update, Delete) 트랜잭션을 커밋한다.
    - 이 쓰기의 효과로 2단계를 결정한 전제 조건이 바뀐다. 다시 말해 쓰기를 커밋한 후 1단계의 SELECT 질의를 재실행하면 다른 결과를 얻게 된다.
      쓰기의 결과로 검색 조건에 부합하는 로우 집합이 바뀌었기 때문이다. 
        - 호출 대기하는 의사가 한 명 줄었다. 
        - 해당 시간에 회의실이 예약됐다.
        - 옮겨진 물체가 게임판의 특정 위치를 차지했다.
        - 사용자명이 점유됐다.
        - 계좌에 남은 돈이 줄었다.
- 팬텀(phantom) : 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과

### 직렬성
- 격리 수준은 이해하기 어렵고 데이터베이스마다 그 구현에 일관성이 없다.
- 애플리케이션 코드를 보고 특정한 격리 수준에서 해당 코드를 실행하는 게 안전한지 알기 어렵다. 특히 동시에 일어나는 모든 일을 알지 못할 수도 있는 거대한 애플리케이션이라면 더 그렇다.
- 경쟁 조건을 감지하는 데 도움이 되는 좋은 도구가 없다. 이론상으로는 정적 분석이 도움될지 모르지만 아직 현실적으로 사용되는 연구 기법은 없다. 동시성 문제는 보통 비결정적이라서 테스트하기 어렵다. 타이밍이 좋지 못할 때만 문제가 발생한다.
- 직렬성 격리를 사용하라!

#### 실제적인 직렬실행

#### 2단계 잠금 (two-phase locking)
#### 직렬성 스냅숏 격리(Serializable snapshot isolation)