---
title: designing-data-intensive-application-7
date: 2020-09-28 11:27:19
tags:
- transaction
---
### 현실세계 문제점
- 데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있다.
- 애플리케이션은 언제라도 죽을 수 있다.
- 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안 될 수 있다.
- 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
- 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다.
- 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.

### Transaction mechanism
- 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이다.
- 개념적으로 한 트랜잭션 내의 모든 읽기와 쓰기는 한 연산으로 실행된다.
- 트랜잭션은 전체가 성공하거나 실패한다.

### ACID
- 테오 하더(Theo Harder), 안드레아스 로이터(Andreas Reuter)는 데이터 베이스에서 내결함성 메커니즘을 나타내는 용어를 확립했다.
- Atomicity(원자성)
- Consistency(일관성)
- Isolation(격리성)
- Durability(지속성)
- 그러나 현실에서는 데이터베이스마다 ACID구현이 제각각이다. 
- ACID compliant 한다고 할때 그 시스템에서 실제로 어떤 것을 기대할 수 있는지 분명하지 않다. (ACID 표준을 따르지 않는 시스템은 때로 BASE라고 불린다.)
    - Basically Available
    - Atomicity
    - Soft state
    - Eventual Consistency

### Atomicity
- 일반적으로 원자적이란 더 작은 부분으로 쪼갤 수 없는 뭔가를 가리킨다.
    - 시스템은 연산을 실행하기 전이나 실행한 후의 상태에만 있을 수 있으며 그 중간 상태에는 머물수 없다.
    - ACID의 맥락에서 보면 원자성은 동시성과 관련이 없다.
    - 여러 쓰기 작업이 하나의 원자적 인 트랜잭션으로 묶여 있는데 결함 때문에 왼료(커밋)될 수 없다면 어보트되고 
      데이터베이스는 이 트랜잭션에서 지금끼지 실행한 쓰기를 무시하거나 취소해야 한다.
    - 어보트 능력 (abortability)이 원자성 보다 나은 단어겠지만 원자성이 자주 쓰이므로 이 단어를 계속 사용하겠다.

### Consistency
- 유감스럽게도 같은 단어가 최소 네가지 의미로 쓰이고 있다.
- 복제 일관성(replica consistency)과 비동기식으로 복제되는 시스템에서 발생하는 최종적 일관성(eventualconsistency) 문제에 대해 설명했다
- 일관성 해싱은 어떤 시스템들에서 재균형화를 위해 사용하는 파티셔닝방법이다.
- CAP 정리(9장 침고)에서 일관성이란 닫어는 선형성(Iinearizability)을 의미한다
- ACID의 맥락에서 일관성은 데이터베이스가 “좋은 상태”에 있어야 한다는 것의 애플리케이션에 특화된 개념을 가리킨다，
- 데이터에 관한 어떤 선언 (불변식 {invariant})이 있다는 것이다.

### Isolation
![](/images/data-intensive/chapter_7/transaction_isolation.png)
- 격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다.
- 데이터베이스는 실제로는 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.
- 직렬성 격리(serializable isolation)는 성능 손해를 동반하므로 현실에서는 거의 시용되지 않는다.

### durability
- 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.

### 다중 객체 트랜잭션의 필요성

### read commited
- 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다(더티 읽기가 없음)
- 데이터베이스에서 쓸 때 커밋된 데이터만 덮어쓰게 된다(더티 쓰기가 없음)

### 더티 읽기 방지
![](/images/data-intensive/chapter_7/prevent_dirty_read.png)
- 트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 생기면 다른 트랜잭션이 일부는 갱신된 값을， 일부는 갱신되지 않은 값을 볼수있다 
- 트랜잭션이 어보트되면 그때까지 쓴 내용은 모두 롤백돼야 한다. 데이터베이스가 더티 읽기를 허용하면 트랜잭션이 나중에 롤백될 데이터， 
  즉 실제로는 데이터베이스에 결코 커멋되지 않을 데이터를 볼 수 있다 그 결과를 따져보려 하면 곧 머리가 흔란스러워질 것이다.
  
### 더티 쓰기 방지
- 먼저 쓴 내용이 아직 커잇되지 않은 트랜잭션에서 쓴 것이고 니중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어써버리면 어떻게 될까?
