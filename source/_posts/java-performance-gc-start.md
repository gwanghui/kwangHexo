---
title: java-performance-gc-start
date: 2020-08-16 14:20:14
tags:
---

- 참조
https://docs.oracle.com/en/java/javase/14/gctuning/garbage-first-g1-garbage-collector1.html#GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573

### GC의 기본 동작
- 미사용 객체 찾기
- 가용 메모리 생성
- 힙 압축

### G1 컬렉터 (Garbage First Collector)
- 미사용 객체를 훑어보는 동안 어플리케이션 스레드를 멈추지 않고도 처리한다. (Concurrent Collector)
- low pause collector
- 4GB 이상의 큰 힙을 처리하도록 설계
- 힙을 여러 개의 영역으로 나누지만 여전히 제네레이션 기반의 컬렉터이다.
- 이 영역의 일부는 영 제네레이션을 구성하고, 영 제네레이션은 여전히 모든 어플리케이션 스레드를 멈추고 
  올드 제네레이션이나 서바이버 스페이스로 살아 있는 객체 전부를 이동하면서 수집된다.
- Background thread 로 올드 제네레이션을 처리하며, 이는 여러 영역으로 나뉘기 때문에 한 영역에서 다른 영역으로 복사해 올드 제네레이션에서
  객체 삭제가 가능하며, 일반적인 처리를 하는 동안 힙을 부분적으로 압축이 가능하다.
   
   
### GC 설정
- 힙 크기 정하기
    - 힙이 너무 작다면 프로그램은 GC의 수행 횟수가 많아져 수행시간이 늘어날 것이고, 힙이 매우 크다면 한번의 GC실행에 많은 시간을 소요할 것이다.
    - 실제 기동되는 것보다 더 큰 힙을 사용할 경우 OS는 가상 메모리를 사용한다. 이는 memory swapping 혹은 paging이라는 방식으로 이를 관리한다.
    - OS에서 많은 어플리케이션이 실행 되고 있을 경우에는 효과적(대부분의 어플리케이션은 동시에 활성화 되지 않는다고 가정했을때)이다 
    - 자바 어플리케이션 1개가 물리적인 메모리 사용 공간을 넘어 힙을 사용할 경우에는 GC시 디스크에서 RAM으로 데이터를 swap하면서 심한 성능상의 불이익을 초래한다.
    - 명시적으로 최대 크기를 설정하더라도 힙의 크기가 자동으로 조정된다. 힙은 디폴트 초기 크기로 시작하고, JVM은 GC 알고리즘의 성능 목표를 만족시키기 위해 힙을 늘릴 것이다.
    - 필요로 하는 것보다 더 큰 힙을 명시한다고 해서 반드시 메모리상 불이익을 받는 것은 아니다.
    - java 7 permgen, java 8 metaspace
- 병렬성 제어하기
    - G1의 모든 어플리케이션 스레드 중간단계의 GC동작은 어플리케이션 스레드가 실행되는 걸 막기 떄문에 JVM은 중지시간을 최소화 하기 위해 가능한 CPU 자원을 많이 사용하고자 한다.
    - 이건 기본적으로 JVM이 한 머신 내의 각 CPU당 스레드 한개씩 8개까지 실행한다는 의미이다. 임계치에 다다르면 JVM은 CPU 한 개의 5/8마다 신규 스레드 한개만 추가한다.
    - 8개 이상의 CPU를 갖고 있는 머신 한 개에서 스레드의 총 개수는 다음과 같다.
        - ParallelGCThreads = 8 + ((N - 8) * 5 /8)
- 적응 크기 조정
    - 힙, 제네레이션과 서바이버 스페이스의 크기는 JVM이 정책과 튜닝에 따라 최적의 성능을 찾고자 시도하면서 실행되는 동안 달라질 수 있다.
    - 작은 어플리케이션은 힙 크기의 과도한 지정에 대해 걱정할 필요가 없다는 것을 의미한다.
    - 대다수의 어플리케이션들은 실제로 힙 사이즈에 대한 튜닝을 전혀 걱정할 필요가 없다는 의미이다. 플랫폼 디폴트보다 더 큰 힙을 필요로 하면 힙의 크기를 더 크게 명시하기만 하고 다른 세부 사항에 대해서는 잊어버릴 수 있다.

### Throughput Collector (처리율 컬렉터 ) 이해하기
![](/images/java/performance/java_performance_gc_heap_structure.png)

- Minor GC (Young Collection)
![](/images/java/performance/java_performance_gc_heap_minor_gc.png)
    - Young Generation이 가득 찼을 때 일어나며, 모든 객체를 에덴의 밖으로 옮긴다. 일부는 서바이버 스페이스 중의 하나로 옮기고, 
      일부는 올드 제네레이션으로 옮기므로 이후에는 더 많은 객체를 갖게 된다.
      ```text
        17.806: [GC[PSYoungGen: 2227983K->14463K(264128K)]
           280122K->66610K(613696K), 0.0169320 secs]
           [Times: user=0.05 sys=0.00, real=0.02 secs]   
      ```
    - 현재 영 제네레이션의 전체 크기는 264MB, 힙의 전반적인 사용량(영,올드 제네레이션)은 280MB -> 64MB, 전체 610MB

- Full GC (Old Generation)
![](/images/java/performance/java_performance_gc_heap_full_gc.png)
    - Full GC는 영 제네레이션 외의 모든걸 해제한다. 올드 제네레이션에 남아있는 객체들은 유효한 참조를 갖고 있는 것 뿐이며, 
      올드 제네레이션에 남아 있는 객체들은 유효한 참조를 가지고 있는 것 뿐이다.
    - 올드 제네레이션의 객체들은 전부 압축되어 올드 제네레이션의 앞 부분을 점유하고 있고 나머지는 해제 된다.
      ```text
        64.546: [Full GC [PSYoungGen: 15808K->0K(339456K)]
           [ParOldGen: 457753K -> 392528K(554432K)]  473561K -> 392528K (893888K)
           [PSPermGen: 56728K -> 56728K (115392K)], 1.3367080 secs] 
           [Times: user=4.44 sys=0.01, real=1.34 secs]   
      ``` 
    - 영제네레이션은 이제 0Byte를 점유한다. (크기는 339MB)
    - 올드 제네레이션의 크기는 457MB -> 392MB로 줄어들었다.
    - 퍼머넌트 제네레이션의 크기는 변함없다. 대부분의 풀 GC가 일어나는 동안 여기는 수집하지 않는다. 
    - 퍼머넌트 제네레이션이 공간을 다 써버리면 JVM은 퍼머넌트 제네레이션을 수집하기 위해 풀 GC를 수행한다. 이때 변경되는 것을 볼 수 있다.
- 적응과 정적 힙 크기 튜닝
    - 처리율 컬렉터 튜닝은 전체 힙 크기와 올드/영 제네레이션 크기 사이의 균형 유지와 중단 시간에 대해서만 고려하면 된다.
    - 1) 시간과 공간에 대한 고전적인 프로그래밍 트레이드 오프사항
    - 2) GC를 수행하는 데 걸리는 시간의 길이와 주기
        - 풀 GC 중단 횟수는 힙 크기를 늘리면 줄일 수 있지만 그로 인해 GC가 더 오래 걸리므로 평균 응답시간이 길어져서 왜곡된 영향을 끼친다.
        - 풀 GC 중단은 올드 제네레이션 보다 영 제네레이션에 더 많은 힙을 할당해서 줄일 수 있지만 결국 올드 GC 컬렉션의 빈도가 늘어난다.
    - GCTimeRatio : 어플리케이션이 GC에 써도 무방할 정도의 시간을 명시한다. 이것은 비율이다 디폴트 값은 99이다. 

### CMS(Concurrent Mark Sweep) Collector 이해하기
- TODO :: CMS!
### G1 collector 이해하기
- G1은 힙 내의 개별 영역에서 동작하는 동시 병렬 컬렉터다.
- 각 영역(Default 2048개)은 올드나 신규 제네레이션에 속할 수 있고 제네레이션의 영역은 인접할 필요는 없다.

- G1은 네 가지의 주요 동작을 한다.
    - 영 컬렉션
    - 백그라운드, 동시 병렬 주기
    - 혼합 컬렉션
    - 필요한 경우 풀 GC
